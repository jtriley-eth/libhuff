// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Script.sol";

function header() pure returns (string memory) {
    return string.concat(
        "// -------------------------------------------------------------------------------------------------\n",
        "// Casting Library\n",
        "//\n",
        "// (generated by the script `script/Gen-libcast.sol`)\n\n"
    );
}

function eq(string memory a, string memory b) pure returns (bool) {
    return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
}

function generateCast(
    string memory typeName,
    string memory bitSize,
    string memory maskValue
) pure returns (string memory) {
    // only do this if the type is greater than 16 bits.
    string memory minimask = eq(bitSize, "16") || eq(bitSize, "8")
        ? "\n"
        : string.concat("#define macro MINI_", typeName, "_MASK() = takes (0) returns (0) { __MINI_MASK(", bitSize, ") }\n\n");

    return string.concat(
        "/// ## ", typeName, " Mask\n",
        "///\n",
        "/// Used to downcast types.\n",
        "///\n",
        "/// The `MINI_", typeName, "_MASK` macro generates a mask that is intended to have a smaller runtime size than\n",
        "/// a full mask at the expense of runtime cost.\n",
        "#define constant ", typeName, "_MASK = ", maskValue, "\n",
        minimask
    );
}

function miniMaskDefinition() pure returns (string memory) {
    return string.concat(
        "/// ## Mini Mask\n",
        "///\n",
        "/// Used as a utility to generate the mask\n",
        "///\n",
        "/// The macro body is functionally equivalent to the following: `2 ** bitsize - 1`\n",
        "///\n",
        "/// ### Template Arguments\n",
        "///\n",
        "/// - `bitsize` - The number of bits to generate a mask for.\n",
        "///\n",
        "/// ### Usage\n",
        "///\n",
        "/// ```huff\n",
        "/// #define macro MINI_U32_MASK() = takes (0) returns (0) { __MINI_MASK(32)}\n",
        "/// ```\n",
        "#define macro __MINI_MASK(bitsize) = takes (0) returns (0) {\n",
        "    0x01        // [one]\n",
        "    dup1        // [one, one]\n",
        "    <bitsize>   // [bisize, one, one]\n",
        "    shl         // [mask_plus_one, one]\n",
        "    sub         // [mask]\n"
        "}\n"
    );
}

contract Gen_libcast is Script {
    function run() public {
        string memory output = string.concat(
            header(),
            generateCast("U8", "8", "0xFF"),
            generateCast("U16", "16", "0xFFFF"),
            generateCast("U32", "32", "0xFFFFFFFF"),
            generateCast("U64", "64", "0xFFFFFFFFFFFFFFFF"),
            generateCast("U128", "128", "0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"),
            generateCast("U256", "256", "0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"),
            miniMaskDefinition()
        );

        vm.writeFile("src/libcast.huff", output);
    }
}
